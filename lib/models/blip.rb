module Rave
  module Models
    # Represents a blip, containing formated text, gadgets and other elements.
    # It is part of a Wavelet within a Wave.
    class Blip < Component
      include Rave::Mixins::TimeUtils
      
      JAVA_CLASS = 'com.google.wave.api.impl.BlipData' # :nodoc:

      # Version number of the contents of the blip [Integer]
      attr_reader :version

      # Annotations on the blip [Array of Annotation]
      attr_reader :annotations
      def annotations # :nodoc:
        @annotations.dup
      end

      # IDs of the children of this blip [Array of String]
      attr_reader :child_blip_ids
      def child_blip_ids # :nodoc:
        @child_blip_ids.map { |id| id.dup }
      end

      # IDs (email addresses) of those who have altered this blip [Array of String]
      attr_reader :contributor_ids
      def contributor_ids # :nodoc:
        @contributor_ids.map { |id| id.dup }
      end

      # Elements contained within this blip [Array of Element]
      attr_reader :elements
      def elements # :nodoc:
        @elements.dup
      end

      # Last time the blip was altered [Time]
      attr_reader :last_modified_time
      def last_modified_time # :nodoc:
        @last_modified_time.dup
      end

      # ID of this blip's parent [String or nil for a root blip]
      attr_reader :parent_blip_id
      def parent_blip_id # :nodoc:
        @parent_blip_id.nil? ? nil : @parent_blip_id.dup
      end

      # ID of the wave this blip belongs to [String]
      attr_reader :wave_id
      def wave_id # :nodoc:
        @wave_id.nil? ? nil : @wave_id.dup
      end

      # ID of the wavelet this blip belongs to [String]
      attr_reader :wavelet_id
      def wavelet_id # :nodoc:
        @wavelet_id.nil? ? nil : @wavelet_id.dup
      end

      # Wavelet that the blip is a part of [Wavelet]
      attr_reader :wavelet
      def wavelet # :nodoc:
        @context.wavelets[@wavelet_id]
      end

      # Wave that this blip is a part of [Wave]
      attr_reader :wave
      def wave # :nodoc:
        @context.waves[@wave_id]
      end

      # Blip that this Blip is a direct reply to. Will be nil if the root blip
      # in a wavelet [Blip or nil for a root blip]
      attr_reader :parent_blip
      def parent_blip # :nodoc:
        @context.blips[@parent_blip_id]
      end

      # Returns true if this is a root blip (no parent blip) [Boolean]
      attr_reader :root?
      def root? # :nodoc:
        @parent_blip_id.nil?
      end

      # Returns true if this is a leaf node (has no children). [Boolean]
      attr_reader :leaf?
      def leaf? # :nodoc:
        @child_blip_ids.empty?
      end

      # Has the blip been deleted? [Boolean]
      attr_reader :deleted?
      def deleted? # :nodoc:
        [:deleted, :null].include? @state
      end

      # Has the blip been completely destroyed? [Boolean]
      attr_reader :null?
      def null? # :nodoc:
        @state == :null
      end

      # Has the blip been generated by the operations of the robot? [Boolean]
      attr_reader :generated?
      def generated? # :nodoc:
        @creation == :generated
      end

      # Has the blip been inferred from reference? [Boolean]
      attr_reader :virtual?
      def virtual? # :nodoc:
        @creation == :virtual
      end

      # Has the blip been passed from wave, rather than being inferred or created locally? [Boolean]
      attr_reader :original?
      def original? # :nodoc:
        @creation == :original
      end

      # Text contained in the blip [String]
      attr_reader :content
      def content # :nodoc:
        @content.dup
      end

      # Users that have made a contribution to the blip [Array of User]
      attr_reader :contributors
      def contributors # :nodoc:
        @contributor_ids.map { |c| @context.users[c] }
      end

      # Original creator of the blip [User]
      attr_reader :creator
      def creator # :nodoc:
        @context.users[@creator]
      end

      # List of direct children of this blip. The first one will be continuing
      # the thread, others will be indented replies [Array of Blip]
      attr_reader :child_blips
      def child_blips # :nodoc:
        @child_blip_ids.map { |id| @context.blips[id] }
      end

      VALID_STATES = [:normal, :null, :deleted] # :nodoc: As passed to initializer in :state option.
      VALID_CREATIONS = [:original, :generated, :virtual] # :nodoc: As passed to initializer in :creation option.
      
      @@next_id = 1 # Unique ID for newly created blips.
      
      #Options include:
      # - :annotations
      # - :child_blip_ids
      # - :content
      # - :contributors
      # - :creator
      # - :elements
      # - :last_modified_time
      # - :parent_blip_id
      # - :version
      # - :wave_id
      # - :wavelet_id
      # - :id
      # - :context
      # - :state
      # - :creation
      def initialize(options = {}) # :nodoc:
        @annotations = options[:annotations] || []
        @child_blip_ids = options[:child_blip_ids] || []
        @content = options[:content] || ''
        @contributor_ids = options[:contributors] || []
        @creator = options[:creator] || User::NOBODY_ID
        @elements = options[:elements] || {}
        @last_modified_time = time_from_json(options[:last_modified_time]) || Time.now
        @parent_blip_id = options[:parent_blip_id]
        @version = options[:version] || -1
        @wave_id = options[:wave_id]
        @wavelet_id = options[:wavelet_id]
        @state = options[:state] || :normal
        @creation = options[:creation] || :original

        unless VALID_STATES.include? @state
          raise ArgumentError.new("Bad state #{options[:state]}. Should be one of #{VALID_STATES.join(', ')}")
        end

        unless VALID_CREATIONS.include? @creation
          raise ArgumentError.new("Bad creation #{options[:creation]}. Should be one of #{VALID_CREATIONS.join(', ')}")
        end

        # If the blip doesn't have a defined ID, since we just created it,
        # assign a temporary, though unique, ID, based on the ID of the wavelet.
        if options[:id].nil?
          options[:id] = "#{GENERATED_PREFIX}_#{@wavelet_id}_#{@@next_id}"
          @@next_id += 1
        end

        super(options)
      end
      
      #Returns true if an annotation with the given name exists in this blip
      def has_annotation?(name)
        @annotations.any? { |a| a.name == name }
      end

      # Adds an annotation to the Blip.
      def add_annotation(annotation)
        @annotations << annotation
        self
      end
      
      #Creates a child blip under this blip
      def create_child_blip
        blip = Blip.new(:wave_id => @wave_id, :parent_blip_id => @id, :wavelet_id => @wavelet_id,
          :context => @context, :contributors => [Robot.instance.id], :creation => :generated)
        @context.add_operation(:type => Operation::BLIP_CREATE_CHILD, :blip_id => @id, :wave_id => @wave_id, :wavelet_id => @wavelet_id, :property => blip)
        add_child_blip(blip)
        blip
      end

      # Adds a created child blip to this blip.
      def add_child_blip(blip) # :nodoc:
        @child_blip_ids << blip.id
        @context.add_blip(blip)
      end

      # INTERNAL
      # Removed a child blip.
      def remove_child_blip(blip) # :nodoc:
        @child_blip_ids.delete(blip.id)

        # Destroy oneself completely if you are no longer useful to structure.
        destroy_me if deleted? and leaf? and not root?
      end
      
      # Delete this blip from its wavelet.
      # Returns the blip id.
      def delete
        if deleted?
          LOGGER.warning("Attempt to delete blip that has already been deleted: #{id}")
        elsif root?
          LOGGER.warning("Attempt to delete root blip: #{id}")
        else
          @context.add_operation(:type => Operation::BLIP_DELETE,
            :blip_id => @id, :wave_id => @wave_id, :wavelet_id => @wavelet_id)
          delete_me
        end
      end

      # Convert to string.
      def to_s
        str = @content.gsub(/\n/, "\\n")
        str = str.length > 24 ? "#{str[0..20]}..." : str
        
        str = case @state
        when :normal
          "#{contributors.join(',')}:#{str}"
        when :deleted
          '<DELETED>'
        when :null
          '<NULL>'
        end

        "#{super}:#{str}"
      end

      # *INTERNAL*
      # Write out a formatted block of text showing the blip and its descendants.
      def print_structure(indent = 0) # :nodoc:
        str = "#{'  ' * indent}#{to_s}\n"
        
        children = child_blips

        # All children, except the first, should be indented.
        children.each_with_index do |blip, index|
          # Gap between reply chains.
          if index > 1
            str << "\n"
          end

          if index > 0
            str << blip.print_structure(indent + 1)
          end
        end

        if children[0]
          str << children[0].print_structure(indent)
        end

        str
      end

      # *INTERNAL*
      # Convert to json for sending in an operation. We should never need to
      # send more data than this, although blips we receive will have more data.
      def to_json # :nodoc:
        {
          'blipId' => @id,
          'javaClass' => JAVA_CLASS,
          'waveId' => @wave_id,
          'waveletId' => @wavelet_id
        }.to_json
      end

      # *INTERNAL*
      # Delete the blip or, if appropriate, destroy it instead.
      def delete_me(allow_destroy = true) # :nodoc:
        raise "Can't delete root blip" if root?

        if leaf? and allow_destroy
          destroy_me
        else
          # Blip is marked as deleted, but stays in place to maintain structure.
          @state = :deleted
          @content = ''
        end

        @id
      end

    protected
      # *INTERNAL*
      # Remove the blip entirely, leaving it null.
      def destroy_me # :nodoc:
        raise "Can't destroy root blip" if root?
        raise "Can't destroy non-leaf blip" unless leaf?

        # Remove the blip entirely to the realm of oblivion.
        parent_blip.remove_child_blip(self)
        @parent_blip_id = nil
        @context.remove_blip(self)
        @state = :null
        @content = ''

        @id
      end
    end
  end
end
